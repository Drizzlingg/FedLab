# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, SMILE Lab
# This file is distributed under the same license as the FedLab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FedLab \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-28 12:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../source/tutorials/tutorial_2.rst:5
msgid "Communication Strategy"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:7
msgid ""
"Communication strategy is implemented by ClientManager and ServerManager "
"together."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:9
msgid ""
"The prototype of :class:`NetworkManager` is defined in "
"``fedlab.core.network_manager``, which is also a subclass of "
"``torch.multiprocessing.process``."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:12
msgid ""
"Typically, standard implementations is shown in "
"``fedlab.core.client.manager`` and ``fedlab.core.server.manager``. "
":class:`NetworkManager` manages network operation and control flow "
"procedure."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:16
msgid "Base class definition shows below:"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:61
msgid ""
"FedLab provides 2 standard communication pattern implementations: "
"synchronous and asynchronous. You can customize process flow by: 1. "
"create a new class inherited from corresponding class in our standard "
"implementations; 2. overwrite the functions in target stage."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:65
msgid ""
"To sum up, communication strategy can be customized by overwriting as the"
" note below mentioned."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:69
msgid ""
":meth:`setup()` defines the network initialization stage. Can be used for"
" FL algorithm initialization."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:70
msgid ""
":meth:`main_loop()` is the main process of client and server. User need "
"to define the communication strategy for both client and server manager."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:71
msgid ":meth:`shutdown()` defines the shutdown stage."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:73
msgid ""
"Importantly, ServerManager and ClientManager should be defined and used "
"as a pair. The control flow and information agreements should be "
"compatible. FedLab provides standard implementation for typical "
"synchronous and asynchronous, as depicted below."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:76
msgid "Synchronous"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:78
msgid ""
"Synchronous communication involves :class:`ServerSynchronousManager` and "
":class:`ClientPassiveManager`. Communication procedure is shown as "
"follows."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:89
msgid "Asynchronous"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:91
msgid ""
"Asynchronous is given by :class:`ServerAsynchronousManager` and "
":class:`ClientActiveManager`. Communication procedure is shown as "
"follows."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:103
msgid "Initialization stage"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:105
msgid "Initialization stage is represented by :meth:`manager.setup()` function."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:107
msgid ""
"User can customize initialization procedure as follows(use ClientManager "
"as example):"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:127
msgid "Communication stage"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:129
msgid ""
"After Initialization Stage, user can define :meth:`main_loop()` to define"
" main process for server and client. To standardize **FedLab**'s "
"implementation, here we give the :meth:`main_loop()` of "
":class:`ClientPassiveManager`: and :class:`ServerSynchronousManager` for "
"example."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:133
msgid "**Client part**:"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:157
msgid "**Server Part**:"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:194
msgid "Shutdown stage"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:196
msgid ""
":meth:`shutdown()` will be called when :meth:`main_loop()` finished. You "
"can define the actions for client and server seperately."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:198
msgid ""
"Typically in our implementation, shutdown stage is started by server. It "
"will send a package with ``MessageCode.Exit`` to inform client to stop "
"its main loop."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:202
msgid ""
"Codes below is the actions of :class:`ServerSynchronousManager` in "
"shutdown stage."
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:221
msgid "Example"
msgstr ""

#: ../../source/tutorials/tutorial_2.rst:223
msgid ""
"In fact, the scale module of **FedLab** is a communication strategy re-"
"definition to both ClientManager and ServerManager. Please see the source"
" code in fedlab/core/{client or server}/scale/manager.py (It it really "
"simple. We did nothing but add a map function from rank to client id)."
msgstr ""

